// Code generated by protoc-gen-gogo.
// source: cluegetter.proto
// DO NOT EDIT!

/*
	Package main is a generated protocol buffer package.

	It is generated from these files:
		cluegetter.proto

	It has these top-level messages:
		Proto_Message
		Proto_Session
		Rpc
*/
package core

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

type Proto_Message_Verdict int32

const (
	Proto_Message_PERMIT   Proto_Message_Verdict = 0
	Proto_Message_TEMPFAIL Proto_Message_Verdict = 1
	Proto_Message_REJECT   Proto_Message_Verdict = 2
	Proto_Message_ERROR    Proto_Message_Verdict = 3
	Proto_Message_DISCARD  Proto_Message_Verdict = 4
)

var Proto_Message_Verdict_name = map[int32]string{
	0: "PERMIT",
	1: "TEMPFAIL",
	2: "REJECT",
	3: "ERROR",
	4: "DISCARD",
}
var Proto_Message_Verdict_value = map[string]int32{
	"PERMIT":   0,
	"TEMPFAIL": 1,
	"REJECT":   2,
	"ERROR":    3,
	"DISCARD":  4,
}

func (x Proto_Message_Verdict) String() string {
	return proto.EnumName(Proto_Message_Verdict_name, int32(x))
}
func (Proto_Message_Verdict) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCluegetter, []int{0, 0}
}

type Proto_Message struct {
	Session                *Proto_Session               `protobuf:"bytes,1,opt,name=session" json:"session,omitempty"`
	Id                     string                       `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	From                   string                       `protobuf:"bytes,3,opt,name=from,proto3" json:"from,omitempty"`
	Rcpt                   []string                     `protobuf:"bytes,4,rep,name=rcpt" json:"rcpt,omitempty"`
	Headers                []*Proto_Message_Header      `protobuf:"bytes,5,rep,name=headers" json:"headers,omitempty"`
	Body                   []byte                       `protobuf:"bytes,6,opt,name=body,proto3" json:"body,omitempty"`
	Verdict                Proto_Message_Verdict        `protobuf:"varint,7,opt,name=verdict,proto3,enum=main.Proto_Message_Verdict" json:"verdict,omitempty"`
	VerdictMsg             string                       `protobuf:"bytes,8,opt,name=verdictMsg,proto3" json:"verdictMsg,omitempty"`
	RejectScore            float64                      `protobuf:"fixed64,9,opt,name=rejectScore,proto3" json:"rejectScore,omitempty"`
	RejectScoreThreshold   float64                      `protobuf:"fixed64,10,opt,name=rejectScoreThreshold,proto3" json:"rejectScoreThreshold,omitempty"`
	TempfailScore          float64                      `protobuf:"fixed64,11,opt,name=tempfailScore,proto3" json:"tempfailScore,omitempty"`
	TempfailScoreThreshold float64                      `protobuf:"fixed64,12,opt,name=tempfailScoreThreshold,proto3" json:"tempfailScoreThreshold,omitempty"`
	CheckResults           []*Proto_Message_CheckResult `protobuf:"bytes,13,rep,name=checkResults" json:"checkResults,omitempty"`
}

func (m *Proto_Message) Reset()                    { *m = Proto_Message{} }
func (m *Proto_Message) String() string            { return proto.CompactTextString(m) }
func (*Proto_Message) ProtoMessage()               {}
func (*Proto_Message) Descriptor() ([]byte, []int) { return fileDescriptorCluegetter, []int{0} }

func (m *Proto_Message) GetSession() *Proto_Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *Proto_Message) GetHeaders() []*Proto_Message_Header {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *Proto_Message) GetCheckResults() []*Proto_Message_CheckResult {
	if m != nil {
		return m.CheckResults
	}
	return nil
}

type Proto_Message_CheckResult struct {
	MessageId     string                `protobuf:"bytes,1,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	Module        string                `protobuf:"bytes,2,opt,name=module,proto3" json:"module,omitempty"`
	Verdict       Proto_Message_Verdict `protobuf:"varint,3,opt,name=verdict,proto3,enum=main.Proto_Message_Verdict" json:"verdict,omitempty"`
	Score         float64               `protobuf:"fixed64,4,opt,name=score,proto3" json:"score,omitempty"`
	WeightedScore float64               `protobuf:"fixed64,5,opt,name=weightedScore,proto3" json:"weightedScore,omitempty"`
	Duration      float64               `protobuf:"fixed64,6,opt,name=duration,proto3" json:"duration,omitempty"`
	Determinants  []byte                `protobuf:"bytes,7,opt,name=determinants,proto3" json:"determinants,omitempty"`
}

func (m *Proto_Message_CheckResult) Reset()         { *m = Proto_Message_CheckResult{} }
func (m *Proto_Message_CheckResult) String() string { return proto.CompactTextString(m) }
func (*Proto_Message_CheckResult) ProtoMessage()    {}
func (*Proto_Message_CheckResult) Descriptor() ([]byte, []int) {
	return fileDescriptorCluegetter, []int{0, 0}
}

type Proto_Message_Header struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Proto_Message_Header) Reset()         { *m = Proto_Message_Header{} }
func (m *Proto_Message_Header) String() string { return proto.CompactTextString(m) }
func (*Proto_Message_Header) ProtoMessage()    {}
func (*Proto_Message_Header) Descriptor() ([]byte, []int) {
	return fileDescriptorCluegetter, []int{0, 1}
}

type Proto_Session struct {
	InstanceId    uint64 `protobuf:"varint,1,opt,name=instanceId,proto3" json:"instanceId,omitempty"`
	Id            []byte `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	TimeStart     uint64 `protobuf:"varint,3,opt,name=timeStart,proto3" json:"timeStart,omitempty"`
	TimeEnd       uint64 `protobuf:"varint,4,opt,name=timeEnd,proto3" json:"timeEnd,omitempty"`
	SaslUsername  string `protobuf:"bytes,5,opt,name=saslUsername,proto3" json:"saslUsername,omitempty"`
	SaslSender    string `protobuf:"bytes,6,opt,name=saslSender,proto3" json:"saslSender,omitempty"`
	SaslMethod    string `protobuf:"bytes,7,opt,name=saslMethod,proto3" json:"saslMethod,omitempty"`
	CertIssuer    string `protobuf:"bytes,8,opt,name=certIssuer,proto3" json:"certIssuer,omitempty"`
	CertSubject   string `protobuf:"bytes,9,opt,name=certSubject,proto3" json:"certSubject,omitempty"`
	CipherBits    uint32 `protobuf:"varint,10,opt,name=cipherBits,proto3" json:"cipherBits,omitempty"`
	Cipher        string `protobuf:"bytes,11,opt,name=cipher,proto3" json:"cipher,omitempty"`
	TlsVersion    string `protobuf:"bytes,12,opt,name=tlsVersion,proto3" json:"tlsVersion,omitempty"`
	Ip            string `protobuf:"bytes,13,opt,name=ip,proto3" json:"ip,omitempty"`
	ReverseDns    string `protobuf:"bytes,14,opt,name=reverseDns,proto3" json:"reverseDns,omitempty"`
	Hostname      string `protobuf:"bytes,15,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Helo          string `protobuf:"bytes,16,opt,name=helo,proto3" json:"helo,omitempty"`
	MtaHostName   string `protobuf:"bytes,17,opt,name=mtaHostName,proto3" json:"mtaHostName,omitempty"`
	MtaDaemonName string `protobuf:"bytes,18,opt,name=mtaDaemonName,proto3" json:"mtaDaemonName,omitempty"`
}

func (m *Proto_Session) Reset()                    { *m = Proto_Session{} }
func (m *Proto_Session) String() string            { return proto.CompactTextString(m) }
func (*Proto_Session) ProtoMessage()               {}
func (*Proto_Session) Descriptor() ([]byte, []int) { return fileDescriptorCluegetter, []int{1} }

type Rpc struct {
	// For all intents and purposes this field should be
	// considered required. But we may change that in a
	// far away feature, and we like to be forward
	// compatible with our proto buffers.
	Name                   string                       `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Bayes_Learn_Message    *Rpc__Bayes_Learn_Message    `protobuf:"bytes,1024,opt,name=Bayes_Learn_Message,json=bayesLearnMessage" json:"Bayes_Learn_Message,omitempty"`
	Bayes_Learn_Message_Id *Rpc__Bayes_Learn_Message_Id `protobuf:"bytes,1025,opt,name=Bayes_Learn_Message_Id,json=bayesLearnMessageId" json:"Bayes_Learn_Message_Id,omitempty"`
}

func (m *Rpc) Reset()                    { *m = Rpc{} }
func (m *Rpc) String() string            { return proto.CompactTextString(m) }
func (*Rpc) ProtoMessage()               {}
func (*Rpc) Descriptor() ([]byte, []int) { return fileDescriptorCluegetter, []int{2} }

func (m *Rpc) GetBayes_Learn_Message() *Rpc__Bayes_Learn_Message {
	if m != nil {
		return m.Bayes_Learn_Message
	}
	return nil
}

func (m *Rpc) GetBayes_Learn_Message_Id() *Rpc__Bayes_Learn_Message_Id {
	if m != nil {
		return m.Bayes_Learn_Message_Id
	}
	return nil
}

type Rpc__Bayes_Learn_Message struct {
	IsSpam   bool           `protobuf:"varint,1,opt,name=is_spam,json=isSpam,proto3" json:"is_spam,omitempty"`
	Message  *Proto_Message `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
	Host     string         `protobuf:"bytes,17,opt,name=host,proto3" json:"host,omitempty"`
	Reporter string         `protobuf:"bytes,18,opt,name=reporter,proto3" json:"reporter,omitempty"`
	Reason   string         `protobuf:"bytes,19,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *Rpc__Bayes_Learn_Message) Reset()         { *m = Rpc__Bayes_Learn_Message{} }
func (m *Rpc__Bayes_Learn_Message) String() string { return proto.CompactTextString(m) }
func (*Rpc__Bayes_Learn_Message) ProtoMessage()    {}
func (*Rpc__Bayes_Learn_Message) Descriptor() ([]byte, []int) {
	return fileDescriptorCluegetter, []int{2, 0}
}

func (m *Rpc__Bayes_Learn_Message) GetMessage() *Proto_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

type Rpc__Bayes_Learn_Message_Id struct {
	IsSpam    bool   `protobuf:"varint,1,opt,name=is_spam,json=isSpam,proto3" json:"is_spam,omitempty"`
	MessageId string `protobuf:"bytes,2,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	Host      string `protobuf:"bytes,17,opt,name=host,proto3" json:"host,omitempty"`
	Reporter  string `protobuf:"bytes,18,opt,name=reporter,proto3" json:"reporter,omitempty"`
	Reason    string `protobuf:"bytes,19,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *Rpc__Bayes_Learn_Message_Id) Reset()         { *m = Rpc__Bayes_Learn_Message_Id{} }
func (m *Rpc__Bayes_Learn_Message_Id) String() string { return proto.CompactTextString(m) }
func (*Rpc__Bayes_Learn_Message_Id) ProtoMessage()    {}
func (*Rpc__Bayes_Learn_Message_Id) Descriptor() ([]byte, []int) {
	return fileDescriptorCluegetter, []int{2, 1}
}

func init() {
	proto.RegisterType((*Proto_Message)(nil), "main.Proto_Message")
	proto.RegisterType((*Proto_Message_CheckResult)(nil), "main.Proto_Message.CheckResult")
	proto.RegisterType((*Proto_Message_Header)(nil), "main.Proto_Message.Header")
	proto.RegisterType((*Proto_Session)(nil), "main.Proto_Session")
	proto.RegisterType((*Rpc)(nil), "main.Rpc")
	proto.RegisterType((*Rpc__Bayes_Learn_Message)(nil), "main.Rpc._Bayes_Learn_Message")
	proto.RegisterType((*Rpc__Bayes_Learn_Message_Id)(nil), "main.Rpc._Bayes_Learn_Message_Id")
	proto.RegisterEnum("main.Proto_Message_Verdict", Proto_Message_Verdict_name, Proto_Message_Verdict_value)
}
func (m *Proto_Message) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Proto_Message) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Session != nil {
		data[i] = 0xa
		i++
		i = encodeVarintCluegetter(data, i, uint64(m.Session.Size()))
		n1, err := m.Session.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Id) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.Id)))
		i += copy(data[i:], m.Id)
	}
	if len(m.From) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.From)))
		i += copy(data[i:], m.From)
	}
	if len(m.Rcpt) > 0 {
		for _, s := range m.Rcpt {
			data[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Headers) > 0 {
		for _, msg := range m.Headers {
			data[i] = 0x2a
			i++
			i = encodeVarintCluegetter(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Body) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.Body)))
		i += copy(data[i:], m.Body)
	}
	if m.Verdict != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintCluegetter(data, i, uint64(m.Verdict))
	}
	if len(m.VerdictMsg) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.VerdictMsg)))
		i += copy(data[i:], m.VerdictMsg)
	}
	if m.RejectScore != 0 {
		data[i] = 0x49
		i++
		i = encodeFixed64Cluegetter(data, i, uint64(math.Float64bits(float64(m.RejectScore))))
	}
	if m.RejectScoreThreshold != 0 {
		data[i] = 0x51
		i++
		i = encodeFixed64Cluegetter(data, i, uint64(math.Float64bits(float64(m.RejectScoreThreshold))))
	}
	if m.TempfailScore != 0 {
		data[i] = 0x59
		i++
		i = encodeFixed64Cluegetter(data, i, uint64(math.Float64bits(float64(m.TempfailScore))))
	}
	if m.TempfailScoreThreshold != 0 {
		data[i] = 0x61
		i++
		i = encodeFixed64Cluegetter(data, i, uint64(math.Float64bits(float64(m.TempfailScoreThreshold))))
	}
	if len(m.CheckResults) > 0 {
		for _, msg := range m.CheckResults {
			data[i] = 0x6a
			i++
			i = encodeVarintCluegetter(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Proto_Message_CheckResult) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Proto_Message_CheckResult) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MessageId) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.MessageId)))
		i += copy(data[i:], m.MessageId)
	}
	if len(m.Module) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.Module)))
		i += copy(data[i:], m.Module)
	}
	if m.Verdict != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintCluegetter(data, i, uint64(m.Verdict))
	}
	if m.Score != 0 {
		data[i] = 0x21
		i++
		i = encodeFixed64Cluegetter(data, i, uint64(math.Float64bits(float64(m.Score))))
	}
	if m.WeightedScore != 0 {
		data[i] = 0x29
		i++
		i = encodeFixed64Cluegetter(data, i, uint64(math.Float64bits(float64(m.WeightedScore))))
	}
	if m.Duration != 0 {
		data[i] = 0x31
		i++
		i = encodeFixed64Cluegetter(data, i, uint64(math.Float64bits(float64(m.Duration))))
	}
	if len(m.Determinants) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.Determinants)))
		i += copy(data[i:], m.Determinants)
	}
	return i, nil
}

func (m *Proto_Message_Header) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Proto_Message_Header) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if len(m.Value) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.Value)))
		i += copy(data[i:], m.Value)
	}
	return i, nil
}

func (m *Proto_Session) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Proto_Session) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InstanceId != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintCluegetter(data, i, uint64(m.InstanceId))
	}
	if len(m.Id) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.Id)))
		i += copy(data[i:], m.Id)
	}
	if m.TimeStart != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintCluegetter(data, i, uint64(m.TimeStart))
	}
	if m.TimeEnd != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintCluegetter(data, i, uint64(m.TimeEnd))
	}
	if len(m.SaslUsername) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.SaslUsername)))
		i += copy(data[i:], m.SaslUsername)
	}
	if len(m.SaslSender) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.SaslSender)))
		i += copy(data[i:], m.SaslSender)
	}
	if len(m.SaslMethod) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.SaslMethod)))
		i += copy(data[i:], m.SaslMethod)
	}
	if len(m.CertIssuer) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.CertIssuer)))
		i += copy(data[i:], m.CertIssuer)
	}
	if len(m.CertSubject) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.CertSubject)))
		i += copy(data[i:], m.CertSubject)
	}
	if m.CipherBits != 0 {
		data[i] = 0x50
		i++
		i = encodeVarintCluegetter(data, i, uint64(m.CipherBits))
	}
	if len(m.Cipher) > 0 {
		data[i] = 0x5a
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.Cipher)))
		i += copy(data[i:], m.Cipher)
	}
	if len(m.TlsVersion) > 0 {
		data[i] = 0x62
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.TlsVersion)))
		i += copy(data[i:], m.TlsVersion)
	}
	if len(m.Ip) > 0 {
		data[i] = 0x6a
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.Ip)))
		i += copy(data[i:], m.Ip)
	}
	if len(m.ReverseDns) > 0 {
		data[i] = 0x72
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.ReverseDns)))
		i += copy(data[i:], m.ReverseDns)
	}
	if len(m.Hostname) > 0 {
		data[i] = 0x7a
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.Hostname)))
		i += copy(data[i:], m.Hostname)
	}
	if len(m.Helo) > 0 {
		data[i] = 0x82
		i++
		data[i] = 0x1
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.Helo)))
		i += copy(data[i:], m.Helo)
	}
	if len(m.MtaHostName) > 0 {
		data[i] = 0x8a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.MtaHostName)))
		i += copy(data[i:], m.MtaHostName)
	}
	if len(m.MtaDaemonName) > 0 {
		data[i] = 0x92
		i++
		data[i] = 0x1
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.MtaDaemonName)))
		i += copy(data[i:], m.MtaDaemonName)
	}
	return i, nil
}

func (m *Rpc) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Rpc) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if m.Bayes_Learn_Message != nil {
		data[i] = 0x82
		i++
		data[i] = 0x40
		i++
		i = encodeVarintCluegetter(data, i, uint64(m.Bayes_Learn_Message.Size()))
		n2, err := m.Bayes_Learn_Message.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Bayes_Learn_Message_Id != nil {
		data[i] = 0x8a
		i++
		data[i] = 0x40
		i++
		i = encodeVarintCluegetter(data, i, uint64(m.Bayes_Learn_Message_Id.Size()))
		n3, err := m.Bayes_Learn_Message_Id.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *Rpc__Bayes_Learn_Message) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Rpc__Bayes_Learn_Message) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsSpam {
		data[i] = 0x8
		i++
		if m.IsSpam {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Message != nil {
		data[i] = 0x12
		i++
		i = encodeVarintCluegetter(data, i, uint64(m.Message.Size()))
		n4, err := m.Message.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.Host) > 0 {
		data[i] = 0x8a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.Host)))
		i += copy(data[i:], m.Host)
	}
	if len(m.Reporter) > 0 {
		data[i] = 0x92
		i++
		data[i] = 0x1
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.Reporter)))
		i += copy(data[i:], m.Reporter)
	}
	if len(m.Reason) > 0 {
		data[i] = 0x9a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.Reason)))
		i += copy(data[i:], m.Reason)
	}
	return i, nil
}

func (m *Rpc__Bayes_Learn_Message_Id) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Rpc__Bayes_Learn_Message_Id) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsSpam {
		data[i] = 0x8
		i++
		if m.IsSpam {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.MessageId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.MessageId)))
		i += copy(data[i:], m.MessageId)
	}
	if len(m.Host) > 0 {
		data[i] = 0x8a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.Host)))
		i += copy(data[i:], m.Host)
	}
	if len(m.Reporter) > 0 {
		data[i] = 0x92
		i++
		data[i] = 0x1
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.Reporter)))
		i += copy(data[i:], m.Reporter)
	}
	if len(m.Reason) > 0 {
		data[i] = 0x9a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.Reason)))
		i += copy(data[i:], m.Reason)
	}
	return i, nil
}

func encodeFixed64Cluegetter(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Cluegetter(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintCluegetter(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *Proto_Message) Size() (n int) {
	var l int
	_ = l
	if m.Session != nil {
		l = m.Session.Size()
		n += 1 + l + sovCluegetter(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCluegetter(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if len(m.Rcpt) > 0 {
		for _, s := range m.Rcpt {
			l = len(s)
			n += 1 + l + sovCluegetter(uint64(l))
		}
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovCluegetter(uint64(l))
		}
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.Verdict != 0 {
		n += 1 + sovCluegetter(uint64(m.Verdict))
	}
	l = len(m.VerdictMsg)
	if l > 0 {
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.RejectScore != 0 {
		n += 9
	}
	if m.RejectScoreThreshold != 0 {
		n += 9
	}
	if m.TempfailScore != 0 {
		n += 9
	}
	if m.TempfailScoreThreshold != 0 {
		n += 9
	}
	if len(m.CheckResults) > 0 {
		for _, e := range m.CheckResults {
			l = e.Size()
			n += 1 + l + sovCluegetter(uint64(l))
		}
	}
	return n
}

func (m *Proto_Message_CheckResult) Size() (n int) {
	var l int
	_ = l
	l = len(m.MessageId)
	if l > 0 {
		n += 1 + l + sovCluegetter(uint64(l))
	}
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.Verdict != 0 {
		n += 1 + sovCluegetter(uint64(m.Verdict))
	}
	if m.Score != 0 {
		n += 9
	}
	if m.WeightedScore != 0 {
		n += 9
	}
	if m.Duration != 0 {
		n += 9
	}
	l = len(m.Determinants)
	if l > 0 {
		n += 1 + l + sovCluegetter(uint64(l))
	}
	return n
}

func (m *Proto_Message_Header) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovCluegetter(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovCluegetter(uint64(l))
	}
	return n
}

func (m *Proto_Session) Size() (n int) {
	var l int
	_ = l
	if m.InstanceId != 0 {
		n += 1 + sovCluegetter(uint64(m.InstanceId))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.TimeStart != 0 {
		n += 1 + sovCluegetter(uint64(m.TimeStart))
	}
	if m.TimeEnd != 0 {
		n += 1 + sovCluegetter(uint64(m.TimeEnd))
	}
	l = len(m.SaslUsername)
	if l > 0 {
		n += 1 + l + sovCluegetter(uint64(l))
	}
	l = len(m.SaslSender)
	if l > 0 {
		n += 1 + l + sovCluegetter(uint64(l))
	}
	l = len(m.SaslMethod)
	if l > 0 {
		n += 1 + l + sovCluegetter(uint64(l))
	}
	l = len(m.CertIssuer)
	if l > 0 {
		n += 1 + l + sovCluegetter(uint64(l))
	}
	l = len(m.CertSubject)
	if l > 0 {
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.CipherBits != 0 {
		n += 1 + sovCluegetter(uint64(m.CipherBits))
	}
	l = len(m.Cipher)
	if l > 0 {
		n += 1 + l + sovCluegetter(uint64(l))
	}
	l = len(m.TlsVersion)
	if l > 0 {
		n += 1 + l + sovCluegetter(uint64(l))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovCluegetter(uint64(l))
	}
	l = len(m.ReverseDns)
	if l > 0 {
		n += 1 + l + sovCluegetter(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovCluegetter(uint64(l))
	}
	l = len(m.Helo)
	if l > 0 {
		n += 2 + l + sovCluegetter(uint64(l))
	}
	l = len(m.MtaHostName)
	if l > 0 {
		n += 2 + l + sovCluegetter(uint64(l))
	}
	l = len(m.MtaDaemonName)
	if l > 0 {
		n += 2 + l + sovCluegetter(uint64(l))
	}
	return n
}

func (m *Rpc) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.Bayes_Learn_Message != nil {
		l = m.Bayes_Learn_Message.Size()
		n += 2 + l + sovCluegetter(uint64(l))
	}
	if m.Bayes_Learn_Message_Id != nil {
		l = m.Bayes_Learn_Message_Id.Size()
		n += 2 + l + sovCluegetter(uint64(l))
	}
	return n
}

func (m *Rpc__Bayes_Learn_Message) Size() (n int) {
	var l int
	_ = l
	if m.IsSpam {
		n += 2
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovCluegetter(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 2 + l + sovCluegetter(uint64(l))
	}
	l = len(m.Reporter)
	if l > 0 {
		n += 2 + l + sovCluegetter(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 2 + l + sovCluegetter(uint64(l))
	}
	return n
}

func (m *Rpc__Bayes_Learn_Message_Id) Size() (n int) {
	var l int
	_ = l
	if m.IsSpam {
		n += 2
	}
	l = len(m.MessageId)
	if l > 0 {
		n += 1 + l + sovCluegetter(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 2 + l + sovCluegetter(uint64(l))
	}
	l = len(m.Reporter)
	if l > 0 {
		n += 2 + l + sovCluegetter(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 2 + l + sovCluegetter(uint64(l))
	}
	return n
}

func sovCluegetter(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCluegetter(x uint64) (n int) {
	return sovCluegetter(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Proto_Message) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluegetter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Proto_Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Proto_Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Proto_Session{}
			}
			if err := m.Session.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rcpt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rcpt = append(m.Rcpt, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &Proto_Message_Header{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], data[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verdict", wireType)
			}
			m.Verdict = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Verdict |= (Proto_Message_Verdict(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerdictMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerdictMsg = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RejectScore", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.RejectScore = float64(math.Float64frombits(v))
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RejectScoreThreshold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.RejectScoreThreshold = float64(math.Float64frombits(v))
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TempfailScore", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.TempfailScore = float64(math.Float64frombits(v))
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TempfailScoreThreshold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.TempfailScoreThreshold = float64(math.Float64frombits(v))
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckResults = append(m.CheckResults, &Proto_Message_CheckResult{})
			if err := m.CheckResults[len(m.CheckResults)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluegetter(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluegetter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proto_Message_CheckResult) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluegetter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verdict", wireType)
			}
			m.Verdict = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Verdict |= (Proto_Message_Verdict(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Score = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightedScore", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.WeightedScore = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Duration = float64(math.Float64frombits(v))
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Determinants", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Determinants = append(m.Determinants[:0], data[iNdEx:postIndex]...)
			if m.Determinants == nil {
				m.Determinants = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluegetter(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluegetter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proto_Message_Header) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluegetter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluegetter(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluegetter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proto_Session) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluegetter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Proto_Session: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Proto_Session: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceId", wireType)
			}
			m.InstanceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.InstanceId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], data[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeStart", wireType)
			}
			m.TimeStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TimeStart |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeEnd", wireType)
			}
			m.TimeEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TimeEnd |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaslUsername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SaslUsername = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaslSender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SaslSender = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaslMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SaslMethod = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertIssuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertIssuer = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertSubject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertSubject = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CipherBits", wireType)
			}
			m.CipherBits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CipherBits |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cipher", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cipher = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReverseDns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReverseDns = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Helo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Helo = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MtaHostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MtaHostName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MtaDaemonName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MtaDaemonName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluegetter(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluegetter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rpc) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluegetter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rpc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rpc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 1024:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bayes_Learn_Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bayes_Learn_Message == nil {
				m.Bayes_Learn_Message = &Rpc__Bayes_Learn_Message{}
			}
			if err := m.Bayes_Learn_Message.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 1025:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bayes_Learn_Message_Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bayes_Learn_Message_Id == nil {
				m.Bayes_Learn_Message_Id = &Rpc__Bayes_Learn_Message_Id{}
			}
			if err := m.Bayes_Learn_Message_Id.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluegetter(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluegetter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rpc__Bayes_Learn_Message) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluegetter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: _Bayes_Learn_Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: _Bayes_Learn_Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSpam", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSpam = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &Proto_Message{}
			}
			if err := m.Message.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reporter = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluegetter(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluegetter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rpc__Bayes_Learn_Message_Id) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluegetter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: _Bayes_Learn_Message_Id: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: _Bayes_Learn_Message_Id: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSpam", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSpam = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reporter = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluegetter(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluegetter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCluegetter(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCluegetter
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCluegetter
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCluegetter
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCluegetter(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCluegetter = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCluegetter   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorCluegetter = []byte{
	// 901 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x55, 0xcd, 0x6e, 0x23, 0x45,
	0x10, 0x5e, 0xc7, 0x13, 0xff, 0x94, 0x9d, 0xe0, 0xed, 0x44, 0xd9, 0x91, 0x81, 0x10, 0x2c, 0x0e,
	0x5c, 0xb0, 0x50, 0xf8, 0x39, 0x70, 0x23, 0x59, 0xa3, 0x35, 0x5a, 0xb3, 0x51, 0x3b, 0xc0, 0xd1,
	0x9a, 0xcc, 0xd4, 0x66, 0x86, 0xf5, 0xfc, 0xa8, 0xbb, 0xbd, 0x28, 0x37, 0xb8, 0xf1, 0x08, 0x70,
	0xe0, 0xca, 0xb3, 0x70, 0xe4, 0x11, 0x10, 0x3c, 0x04, 0x1c, 0xe9, 0xaa, 0x9e, 0x89, 0xc7, 0xc1,
	0x41, 0x42, 0xda, 0xc3, 0x48, 0x55, 0x5f, 0x7f, 0x5d, 0xdd, 0xf5, 0x75, 0x55, 0x0d, 0x0c, 0xc2,
	0xe5, 0x0a, 0xaf, 0xd1, 0x18, 0x54, 0xe3, 0x42, 0xe5, 0x26, 0x17, 0x5e, 0x1a, 0x24, 0xd9, 0xe8,
	0xef, 0x16, 0xec, 0x5d, 0x90, 0xbf, 0x98, 0xa1, 0xd6, 0xc1, 0x35, 0x8a, 0xf7, 0xa0, 0xad, 0xad,
	0x99, 0xe4, 0x99, 0xdf, 0x38, 0x69, 0xbc, 0xdb, 0x3b, 0x3d, 0x18, 0x13, 0x73, 0xec, 0x58, 0x73,
	0xb7, 0x24, 0x2b, 0x8e, 0xd8, 0x87, 0x9d, 0x24, 0xf2, 0x77, 0x2c, 0xb3, 0x2b, 0xad, 0x25, 0x04,
	0x78, 0xcf, 0x55, 0x9e, 0xfa, 0x4d, 0x46, 0xd8, 0x26, 0x4c, 0x85, 0x85, 0xf1, 0xbd, 0x93, 0x26,
	0x61, 0x64, 0x8b, 0x0f, 0xa1, 0x1d, 0x63, 0x10, 0xa1, 0xd2, 0xfe, 0xae, 0x85, 0x7b, 0xa7, 0xc3,
	0xfa, 0x31, 0xe5, 0x65, 0xc6, 0x4f, 0x98, 0x22, 0x2b, 0x2a, 0x45, 0xba, 0xca, 0xa3, 0x1b, 0xbf,
	0x65, 0xa3, 0xf7, 0x25, 0xdb, 0xe2, 0x23, 0x68, 0xbf, 0x44, 0x15, 0x25, 0xa1, 0xf1, 0xdb, 0x16,
	0xde, 0x3f, 0x7d, 0x7d, 0x5b, 0xa4, 0xaf, 0x1c, 0x45, 0x56, 0x5c, 0x71, 0x0c, 0x50, 0x9a, 0x33,
	0x7d, 0xed, 0x77, 0xf8, 0xba, 0x35, 0x44, 0x9c, 0x40, 0x4f, 0xe1, 0x37, 0x18, 0x9a, 0x79, 0x98,
	0x2b, 0xf4, 0xbb, 0x96, 0xd0, 0x90, 0x75, 0x48, 0x9c, 0xc2, 0x61, 0xcd, 0xbd, 0x8c, 0x15, 0xea,
	0x38, 0x5f, 0x46, 0x3e, 0x30, 0x75, 0xeb, 0x9a, 0x78, 0x07, 0xf6, 0x0c, 0xa6, 0xc5, 0xf3, 0x20,
	0x59, 0xba, 0xb8, 0x3d, 0x26, 0x6f, 0x82, 0xe2, 0x63, 0x38, 0xda, 0x00, 0xd6, 0xb1, 0xfb, 0x4c,
	0xbf, 0x67, 0x55, 0x9c, 0x43, 0x3f, 0x8c, 0x31, 0x7c, 0x21, 0x51, 0xaf, 0x96, 0x46, 0xfb, 0x7b,
	0xac, 0xec, 0x5b, 0xdb, 0xf4, 0x38, 0x5f, 0xf3, 0xe4, 0xc6, 0xa6, 0xe1, 0x5f, 0x0d, 0xe8, 0xd5,
	0x56, 0xc5, 0x9b, 0x00, 0xa9, 0xdb, 0xb4, 0xb0, 0x2f, 0xdd, 0x60, 0xa1, 0xba, 0x25, 0x32, 0x8d,
	0xc4, 0x11, 0xb4, 0xd2, 0x3c, 0x5a, 0x2d, 0xb1, 0x2c, 0x82, 0xd2, 0xab, 0x3f, 0x4b, 0xf3, 0x7f,
	0x3c, 0xcb, 0x21, 0xec, 0x6a, 0x16, 0xc6, 0xe3, 0x4c, 0x9d, 0x43, 0xb2, 0x7d, 0x8b, 0xc9, 0x75,
	0x6c, 0x30, 0x72, 0xb2, 0xed, 0x3a, 0xd9, 0x36, 0x40, 0x31, 0x84, 0x4e, 0xb4, 0x52, 0x81, 0xa1,
	0xda, 0x6d, 0x31, 0xe1, 0xd6, 0x17, 0x23, 0xe8, 0x47, 0x68, 0xab, 0x3f, 0x4d, 0xb2, 0x20, 0xb3,
	0xd2, 0xb4, 0xb9, 0x82, 0x36, 0xb0, 0xe1, 0xfb, 0xd0, 0x72, 0x05, 0x27, 0x06, 0xd0, 0x7c, 0x81,
	0x37, 0x65, 0xb2, 0x64, 0xd2, 0xbd, 0x5e, 0x06, 0xb6, 0x87, 0xca, 0x2c, 0x9d, 0x33, 0xfa, 0x04,
	0xda, 0x65, 0x06, 0x02, 0xa0, 0x75, 0x31, 0x91, 0xb3, 0xe9, 0xe5, 0xe0, 0x81, 0xe8, 0x43, 0xe7,
	0x72, 0x32, 0xbb, 0xf8, 0xec, 0xd3, 0xe9, 0xd3, 0x41, 0x83, 0x56, 0xe4, 0xe4, 0xf3, 0xc9, 0xf9,
	0xe5, 0x60, 0x47, 0x74, 0x61, 0x77, 0x22, 0xe5, 0x33, 0x39, 0x68, 0x8e, 0x7e, 0xf6, 0xaa, 0xd6,
	0x2b, 0x9b, 0x8a, 0x4a, 0x32, 0xc9, 0xb4, 0x09, 0xb2, 0xd0, 0x0a, 0xcb, 0x87, 0x7b, 0xb2, 0x86,
	0xd4, 0x7a, 0xad, 0xcf, 0xbd, 0xf6, 0x06, 0x74, 0x4d, 0x92, 0xe2, 0xdc, 0x04, 0xca, 0x89, 0xec,
	0xc9, 0x35, 0x20, 0x7c, 0x68, 0x93, 0x33, 0xc9, 0x22, 0xd6, 0xd2, 0x93, 0x95, 0x4b, 0x5a, 0xe8,
	0x40, 0x2f, 0xbf, 0xd4, 0xa8, 0xb2, 0x20, 0x75, 0x62, 0x76, 0xe5, 0x06, 0x46, 0x77, 0x21, 0x7f,
	0x8e, 0x99, 0xd5, 0x83, 0xd5, 0xb4, 0xed, 0xb1, 0x46, 0xaa, 0xf5, 0x19, 0x9a, 0x38, 0x8f, 0x58,
	0xcd, 0x72, 0xdd, 0x21, 0xb4, 0x1e, 0xa2, 0x32, 0x53, 0xad, 0x57, 0x76, 0x7f, 0xd9, 0x5e, 0x6b,
	0x84, 0xda, 0x8b, 0xbc, 0xf9, 0xea, 0x8a, 0xba, 0x84, 0xdb, 0xab, 0x2b, 0xeb, 0x10, 0x47, 0x48,
	0x8a, 0x18, 0xd5, 0x59, 0x62, 0xdf, 0x8b, 0x9a, 0x6a, 0x4f, 0xd6, 0x10, 0x2a, 0x3c, 0xe7, 0x71,
	0x0f, 0xd9, 0xc2, 0x73, 0x1e, 0xed, 0x33, 0x4b, 0x6d, 0x9f, 0x85, 0x67, 0x58, 0xdf, 0x9d, 0xbc,
	0x46, 0x58, 0xc5, 0xc2, 0xb6, 0x86, 0x9b, 0x58, 0x05, 0xf1, 0x15, 0xda, 0xf2, 0xd3, 0xf8, 0x38,
	0xd3, 0xfe, 0xbe, 0xe3, 0xaf, 0x11, 0xaa, 0xaa, 0x38, 0xd7, 0x86, 0x95, 0x7a, 0x8d, 0x57, 0x6f,
	0x7d, 0x9a, 0x47, 0x31, 0x2e, 0x73, 0x7f, 0xe0, 0xa6, 0x1d, 0xd9, 0x94, 0x59, 0x6a, 0x82, 0x27,
	0x96, 0xf2, 0x05, 0x6d, 0x79, 0xe8, 0x32, 0xab, 0x41, 0x54, 0xcd, 0xd6, 0x7d, 0x1c, 0x60, 0x9a,
	0x67, 0xcc, 0x11, 0xcc, 0xd9, 0x04, 0x47, 0x3f, 0x78, 0xd0, 0x94, 0x45, 0x48, 0x67, 0xf0, 0xd9,
	0xae, 0x18, 0xd9, 0x16, 0xcf, 0xe0, 0xe0, 0x2c, 0xb8, 0x41, 0xbd, 0x78, 0x8a, 0x81, 0xca, 0xaa,
	0x6e, 0xf2, 0xbf, 0xeb, 0xf0, 0xc4, 0x3e, 0x76, 0x9d, 0x66, 0x37, 0x8f, 0x17, 0x5b, 0x68, 0xf2,
	0xe1, 0x15, 0x81, 0x8c, 0x55, 0x53, 0xff, 0x6b, 0x38, 0xda, 0xc2, 0x5c, 0xd8, 0x32, 0xfc, 0xde,
	0xc5, 0x7c, 0xfb, 0xbf, 0x63, 0x5a, 0xa6, 0x3c, 0xf8, 0x57, 0xd8, 0x69, 0x34, 0xfc, 0xa5, 0x01,
	0x87, 0xdb, 0x36, 0x88, 0x47, 0xd0, 0x4e, 0xf4, 0x42, 0x17, 0x41, 0xca, 0x99, 0x75, 0x64, 0x2b,
	0xd1, 0x73, 0xeb, 0xd1, 0x0f, 0xa8, 0x9c, 0x2e, 0x5c, 0xea, 0x77, 0x7e, 0x40, 0x55, 0x0e, 0x15,
	0x87, 0x9f, 0xc0, 0x0a, 0x5b, 0xea, 0xcc, 0x36, 0x3d, 0x99, 0xc2, 0x22, 0x57, 0xb6, 0xb7, 0x4b,
	0x6d, 0x6f, 0x7d, 0x2a, 0x1b, 0x85, 0x81, 0xb6, 0xa5, 0x71, 0xe0, 0xca, 0xc6, 0x79, 0xc3, 0x9f,
	0x1a, 0xf0, 0xe8, 0x9e, 0xcc, 0xee, 0xbf, 0xeb, 0xe6, 0x6c, 0xdc, 0xb9, 0x3b, 0x1b, 0x5f, 0xd1,
	0xdd, 0xce, 0x06, 0xbf, 0xfe, 0x71, 0xdc, 0xf8, 0xcd, 0x7e, 0xbf, 0xdb, 0xef, 0xc7, 0x3f, 0x8f,
	0x1f, 0x5c, 0xb5, 0xf8, 0x27, 0xfe, 0xc1, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x08, 0x3a, 0xa2,
	0x0f, 0xd8, 0x07, 0x00, 0x00,
}
