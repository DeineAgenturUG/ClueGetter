// Code generated by protoc-gen-gogo.
// source: cluegetter.proto
// DO NOT EDIT!

/*
	Package main is a generated protocol buffer package.

	It is generated from these files:
		cluegetter.proto

	It has these top-level messages:
		Proto_MessageV1
*/
package main

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import github_com_golang_protobuf_proto "github.com/golang/protobuf/proto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Proto_MessageV1_Verdict int32

const (
	Proto_MessageV1_PERMIT   Proto_MessageV1_Verdict = 0
	Proto_MessageV1_TEMPFAIL Proto_MessageV1_Verdict = 1
	Proto_MessageV1_REJECT   Proto_MessageV1_Verdict = 2
	Proto_MessageV1_ERROR    Proto_MessageV1_Verdict = 3
)

var Proto_MessageV1_Verdict_name = map[int32]string{
	0: "PERMIT",
	1: "TEMPFAIL",
	2: "REJECT",
	3: "ERROR",
}
var Proto_MessageV1_Verdict_value = map[string]int32{
	"PERMIT":   0,
	"TEMPFAIL": 1,
	"REJECT":   2,
	"ERROR":    3,
}

func (x Proto_MessageV1_Verdict) Enum() *Proto_MessageV1_Verdict {
	p := new(Proto_MessageV1_Verdict)
	*p = x
	return p
}
func (x Proto_MessageV1_Verdict) String() string {
	return proto.EnumName(Proto_MessageV1_Verdict_name, int32(x))
}
func (x *Proto_MessageV1_Verdict) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Proto_MessageV1_Verdict_value, data, "Proto_MessageV1_Verdict")
	if err != nil {
		return err
	}
	*x = Proto_MessageV1_Verdict(value)
	return nil
}

type Proto_MessageV1 struct {
	Session                *Proto_MessageV1_Session       `protobuf:"bytes,1,req,name=session" json:"session,omitempty"`
	Id                     *string                        `protobuf:"bytes,2,req,name=id" json:"id,omitempty"`
	From                   *string                        `protobuf:"bytes,3,req,name=from" json:"from,omitempty"`
	Rcpt                   []string                       `protobuf:"bytes,4,rep,name=rcpt" json:"rcpt,omitempty"`
	Headers                []*Proto_MessageV1_Header      `protobuf:"bytes,5,rep,name=headers" json:"headers,omitempty"`
	Body                   []byte                         `protobuf:"bytes,6,opt,name=body" json:"body,omitempty"`
	Verdict                *Proto_MessageV1_Verdict       `protobuf:"varint,7,req,name=verdict,enum=main.Proto_MessageV1_Verdict" json:"verdict,omitempty"`
	VerdictMsg             *string                        `protobuf:"bytes,8,req,name=verdictMsg" json:"verdictMsg,omitempty"`
	RejectScore            *float64                       `protobuf:"fixed64,9,req,name=rejectScore" json:"rejectScore,omitempty"`
	RejectScoreThreshold   *float64                       `protobuf:"fixed64,10,req,name=rejectScoreThreshold" json:"rejectScoreThreshold,omitempty"`
	TempfailScore          *float64                       `protobuf:"fixed64,11,req,name=tempfailScore" json:"tempfailScore,omitempty"`
	TempfailScoreThreshold *float64                       `protobuf:"fixed64,12,req,name=tempfailScoreThreshold" json:"tempfailScoreThreshold,omitempty"`
	CheckResults           []*Proto_MessageV1_CheckResult `protobuf:"bytes,13,rep,name=checkResults" json:"checkResults,omitempty"`
	XXX_unrecognized       []byte                         `json:"-"`
}

func (m *Proto_MessageV1) Reset()         { *m = Proto_MessageV1{} }
func (m *Proto_MessageV1) String() string { return proto.CompactTextString(m) }
func (*Proto_MessageV1) ProtoMessage()    {}

func (m *Proto_MessageV1) GetSession() *Proto_MessageV1_Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *Proto_MessageV1) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *Proto_MessageV1) GetFrom() string {
	if m != nil && m.From != nil {
		return *m.From
	}
	return ""
}

func (m *Proto_MessageV1) GetRcpt() []string {
	if m != nil {
		return m.Rcpt
	}
	return nil
}

func (m *Proto_MessageV1) GetHeaders() []*Proto_MessageV1_Header {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *Proto_MessageV1) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Proto_MessageV1) GetVerdict() Proto_MessageV1_Verdict {
	if m != nil && m.Verdict != nil {
		return *m.Verdict
	}
	return Proto_MessageV1_PERMIT
}

func (m *Proto_MessageV1) GetVerdictMsg() string {
	if m != nil && m.VerdictMsg != nil {
		return *m.VerdictMsg
	}
	return ""
}

func (m *Proto_MessageV1) GetRejectScore() float64 {
	if m != nil && m.RejectScore != nil {
		return *m.RejectScore
	}
	return 0
}

func (m *Proto_MessageV1) GetRejectScoreThreshold() float64 {
	if m != nil && m.RejectScoreThreshold != nil {
		return *m.RejectScoreThreshold
	}
	return 0
}

func (m *Proto_MessageV1) GetTempfailScore() float64 {
	if m != nil && m.TempfailScore != nil {
		return *m.TempfailScore
	}
	return 0
}

func (m *Proto_MessageV1) GetTempfailScoreThreshold() float64 {
	if m != nil && m.TempfailScoreThreshold != nil {
		return *m.TempfailScoreThreshold
	}
	return 0
}

func (m *Proto_MessageV1) GetCheckResults() []*Proto_MessageV1_CheckResult {
	if m != nil {
		return m.CheckResults
	}
	return nil
}

type Proto_MessageV1_Session struct {
	InstanceId       *uint64 `protobuf:"varint,1,req,name=instanceId" json:"instanceId,omitempty"`
	Id               []byte  `protobuf:"bytes,2,req,name=id" json:"id,omitempty"`
	TimeStart        *uint64 `protobuf:"varint,3,req,name=timeStart" json:"timeStart,omitempty"`
	TimeEnd          *uint64 `protobuf:"varint,4,opt,name=timeEnd" json:"timeEnd,omitempty"`
	SaslUsername     *string `protobuf:"bytes,5,opt,name=saslUsername" json:"saslUsername,omitempty"`
	SaslSender       *string `protobuf:"bytes,6,opt,name=saslSender" json:"saslSender,omitempty"`
	SaslMethod       *string `protobuf:"bytes,7,opt,name=saslMethod" json:"saslMethod,omitempty"`
	CertIssuer       *string `protobuf:"bytes,8,opt,name=certIssuer" json:"certIssuer,omitempty"`
	CertSubject      *string `protobuf:"bytes,9,opt,name=certSubject" json:"certSubject,omitempty"`
	CipherBits       *uint32 `protobuf:"varint,10,opt,name=cipherBits" json:"cipherBits,omitempty"`
	Cipher           *string `protobuf:"bytes,11,opt,name=cipher" json:"cipher,omitempty"`
	TlsVersion       *string `protobuf:"bytes,12,opt,name=tlsVersion" json:"tlsVersion,omitempty"`
	Ip               *string `protobuf:"bytes,13,req,name=ip" json:"ip,omitempty"`
	ReverseDns       *string `protobuf:"bytes,14,opt,name=reverseDns" json:"reverseDns,omitempty"`
	Hostname         *string `protobuf:"bytes,15,opt,name=hostname" json:"hostname,omitempty"`
	Helo             *string `protobuf:"bytes,16,opt,name=helo" json:"helo,omitempty"`
	MtaHostName      *string `protobuf:"bytes,17,opt,name=mtaHostName" json:"mtaHostName,omitempty"`
	MtaDaemonName    *string `protobuf:"bytes,18,opt,name=mtaDaemonName" json:"mtaDaemonName,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Proto_MessageV1_Session) Reset()         { *m = Proto_MessageV1_Session{} }
func (m *Proto_MessageV1_Session) String() string { return proto.CompactTextString(m) }
func (*Proto_MessageV1_Session) ProtoMessage()    {}

func (m *Proto_MessageV1_Session) GetInstanceId() uint64 {
	if m != nil && m.InstanceId != nil {
		return *m.InstanceId
	}
	return 0
}

func (m *Proto_MessageV1_Session) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Proto_MessageV1_Session) GetTimeStart() uint64 {
	if m != nil && m.TimeStart != nil {
		return *m.TimeStart
	}
	return 0
}

func (m *Proto_MessageV1_Session) GetTimeEnd() uint64 {
	if m != nil && m.TimeEnd != nil {
		return *m.TimeEnd
	}
	return 0
}

func (m *Proto_MessageV1_Session) GetSaslUsername() string {
	if m != nil && m.SaslUsername != nil {
		return *m.SaslUsername
	}
	return ""
}

func (m *Proto_MessageV1_Session) GetSaslSender() string {
	if m != nil && m.SaslSender != nil {
		return *m.SaslSender
	}
	return ""
}

func (m *Proto_MessageV1_Session) GetSaslMethod() string {
	if m != nil && m.SaslMethod != nil {
		return *m.SaslMethod
	}
	return ""
}

func (m *Proto_MessageV1_Session) GetCertIssuer() string {
	if m != nil && m.CertIssuer != nil {
		return *m.CertIssuer
	}
	return ""
}

func (m *Proto_MessageV1_Session) GetCertSubject() string {
	if m != nil && m.CertSubject != nil {
		return *m.CertSubject
	}
	return ""
}

func (m *Proto_MessageV1_Session) GetCipherBits() uint32 {
	if m != nil && m.CipherBits != nil {
		return *m.CipherBits
	}
	return 0
}

func (m *Proto_MessageV1_Session) GetCipher() string {
	if m != nil && m.Cipher != nil {
		return *m.Cipher
	}
	return ""
}

func (m *Proto_MessageV1_Session) GetTlsVersion() string {
	if m != nil && m.TlsVersion != nil {
		return *m.TlsVersion
	}
	return ""
}

func (m *Proto_MessageV1_Session) GetIp() string {
	if m != nil && m.Ip != nil {
		return *m.Ip
	}
	return ""
}

func (m *Proto_MessageV1_Session) GetReverseDns() string {
	if m != nil && m.ReverseDns != nil {
		return *m.ReverseDns
	}
	return ""
}

func (m *Proto_MessageV1_Session) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func (m *Proto_MessageV1_Session) GetHelo() string {
	if m != nil && m.Helo != nil {
		return *m.Helo
	}
	return ""
}

func (m *Proto_MessageV1_Session) GetMtaHostName() string {
	if m != nil && m.MtaHostName != nil {
		return *m.MtaHostName
	}
	return ""
}

func (m *Proto_MessageV1_Session) GetMtaDaemonName() string {
	if m != nil && m.MtaDaemonName != nil {
		return *m.MtaDaemonName
	}
	return ""
}

type Proto_MessageV1_Header struct {
	Key              *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value            *string `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Proto_MessageV1_Header) Reset()         { *m = Proto_MessageV1_Header{} }
func (m *Proto_MessageV1_Header) String() string { return proto.CompactTextString(m) }
func (*Proto_MessageV1_Header) ProtoMessage()    {}

func (m *Proto_MessageV1_Header) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *Proto_MessageV1_Header) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type Proto_MessageV1_CheckResult struct {
	MessageId        *string                  `protobuf:"bytes,1,req,name=message_id" json:"message_id,omitempty"`
	Module           *string                  `protobuf:"bytes,2,req,name=module" json:"module,omitempty"`
	Verdict          *Proto_MessageV1_Verdict `protobuf:"varint,3,req,name=verdict,enum=main.Proto_MessageV1_Verdict" json:"verdict,omitempty"`
	Score            *float64                 `protobuf:"fixed64,4,req,name=score" json:"score,omitempty"`
	WeightedScore    *float64                 `protobuf:"fixed64,5,req,name=weightedScore" json:"weightedScore,omitempty"`
	Duration         *float64                 `protobuf:"fixed64,6,req,name=duration" json:"duration,omitempty"`
	Determinants     []byte                   `protobuf:"bytes,7,opt,name=determinants" json:"determinants,omitempty"`
	XXX_unrecognized []byte                   `json:"-"`
}

func (m *Proto_MessageV1_CheckResult) Reset()         { *m = Proto_MessageV1_CheckResult{} }
func (m *Proto_MessageV1_CheckResult) String() string { return proto.CompactTextString(m) }
func (*Proto_MessageV1_CheckResult) ProtoMessage()    {}

func (m *Proto_MessageV1_CheckResult) GetMessageId() string {
	if m != nil && m.MessageId != nil {
		return *m.MessageId
	}
	return ""
}

func (m *Proto_MessageV1_CheckResult) GetModule() string {
	if m != nil && m.Module != nil {
		return *m.Module
	}
	return ""
}

func (m *Proto_MessageV1_CheckResult) GetVerdict() Proto_MessageV1_Verdict {
	if m != nil && m.Verdict != nil {
		return *m.Verdict
	}
	return Proto_MessageV1_PERMIT
}

func (m *Proto_MessageV1_CheckResult) GetScore() float64 {
	if m != nil && m.Score != nil {
		return *m.Score
	}
	return 0
}

func (m *Proto_MessageV1_CheckResult) GetWeightedScore() float64 {
	if m != nil && m.WeightedScore != nil {
		return *m.WeightedScore
	}
	return 0
}

func (m *Proto_MessageV1_CheckResult) GetDuration() float64 {
	if m != nil && m.Duration != nil {
		return *m.Duration
	}
	return 0
}

func (m *Proto_MessageV1_CheckResult) GetDeterminants() []byte {
	if m != nil {
		return m.Determinants
	}
	return nil
}

func init() {
	proto.RegisterType((*Proto_MessageV1)(nil), "main.Proto_Message_v1")
	proto.RegisterType((*Proto_MessageV1_Session)(nil), "main.Proto_Message_v1.Session")
	proto.RegisterType((*Proto_MessageV1_Header)(nil), "main.Proto_Message_v1.Header")
	proto.RegisterType((*Proto_MessageV1_CheckResult)(nil), "main.Proto_Message_v1.CheckResult")
	proto.RegisterEnum("main.Proto_MessageV1_Verdict", Proto_MessageV1_Verdict_name, Proto_MessageV1_Verdict_value)
}
func (m *Proto_MessageV1) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Proto_MessageV1) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Session == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintCluegetter(data, i, uint64(m.Session.Size()))
		n1, err := m.Session.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Id == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x12
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.Id)))
		i += copy(data[i:], *m.Id)
	}
	if m.From == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x1a
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.From)))
		i += copy(data[i:], *m.From)
	}
	if len(m.Rcpt) > 0 {
		for _, s := range m.Rcpt {
			data[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Headers) > 0 {
		for _, msg := range m.Headers {
			data[i] = 0x2a
			i++
			i = encodeVarintCluegetter(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Body != nil {
		data[i] = 0x32
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.Body)))
		i += copy(data[i:], m.Body)
	}
	if m.Verdict == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x38
		i++
		i = encodeVarintCluegetter(data, i, uint64(*m.Verdict))
	}
	if m.VerdictMsg == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x42
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.VerdictMsg)))
		i += copy(data[i:], *m.VerdictMsg)
	}
	if m.RejectScore == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x49
		i++
		i = encodeFixed64Cluegetter(data, i, uint64(math.Float64bits(*m.RejectScore)))
	}
	if m.RejectScoreThreshold == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x51
		i++
		i = encodeFixed64Cluegetter(data, i, uint64(math.Float64bits(*m.RejectScoreThreshold)))
	}
	if m.TempfailScore == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x59
		i++
		i = encodeFixed64Cluegetter(data, i, uint64(math.Float64bits(*m.TempfailScore)))
	}
	if m.TempfailScoreThreshold == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x61
		i++
		i = encodeFixed64Cluegetter(data, i, uint64(math.Float64bits(*m.TempfailScoreThreshold)))
	}
	if len(m.CheckResults) > 0 {
		for _, msg := range m.CheckResults {
			data[i] = 0x6a
			i++
			i = encodeVarintCluegetter(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Proto_MessageV1_Session) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Proto_MessageV1_Session) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InstanceId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x8
		i++
		i = encodeVarintCluegetter(data, i, uint64(*m.InstanceId))
	}
	if m.Id == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x12
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.Id)))
		i += copy(data[i:], m.Id)
	}
	if m.TimeStart == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x18
		i++
		i = encodeVarintCluegetter(data, i, uint64(*m.TimeStart))
	}
	if m.TimeEnd != nil {
		data[i] = 0x20
		i++
		i = encodeVarintCluegetter(data, i, uint64(*m.TimeEnd))
	}
	if m.SaslUsername != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.SaslUsername)))
		i += copy(data[i:], *m.SaslUsername)
	}
	if m.SaslSender != nil {
		data[i] = 0x32
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.SaslSender)))
		i += copy(data[i:], *m.SaslSender)
	}
	if m.SaslMethod != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.SaslMethod)))
		i += copy(data[i:], *m.SaslMethod)
	}
	if m.CertIssuer != nil {
		data[i] = 0x42
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.CertIssuer)))
		i += copy(data[i:], *m.CertIssuer)
	}
	if m.CertSubject != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.CertSubject)))
		i += copy(data[i:], *m.CertSubject)
	}
	if m.CipherBits != nil {
		data[i] = 0x50
		i++
		i = encodeVarintCluegetter(data, i, uint64(*m.CipherBits))
	}
	if m.Cipher != nil {
		data[i] = 0x5a
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.Cipher)))
		i += copy(data[i:], *m.Cipher)
	}
	if m.TlsVersion != nil {
		data[i] = 0x62
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.TlsVersion)))
		i += copy(data[i:], *m.TlsVersion)
	}
	if m.Ip == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x6a
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.Ip)))
		i += copy(data[i:], *m.Ip)
	}
	if m.ReverseDns != nil {
		data[i] = 0x72
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.ReverseDns)))
		i += copy(data[i:], *m.ReverseDns)
	}
	if m.Hostname != nil {
		data[i] = 0x7a
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.Hostname)))
		i += copy(data[i:], *m.Hostname)
	}
	if m.Helo != nil {
		data[i] = 0x82
		i++
		data[i] = 0x1
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.Helo)))
		i += copy(data[i:], *m.Helo)
	}
	if m.MtaHostName != nil {
		data[i] = 0x8a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.MtaHostName)))
		i += copy(data[i:], *m.MtaHostName)
	}
	if m.MtaDaemonName != nil {
		data[i] = 0x92
		i++
		data[i] = 0x1
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.MtaDaemonName)))
		i += copy(data[i:], *m.MtaDaemonName)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Proto_MessageV1_Header) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Proto_MessageV1_Header) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.Key)))
		i += copy(data[i:], *m.Key)
	}
	if m.Value == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x12
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.Value)))
		i += copy(data[i:], *m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Proto_MessageV1_CheckResult) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Proto_MessageV1_CheckResult) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MessageId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.MessageId)))
		i += copy(data[i:], *m.MessageId)
	}
	if m.Module == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x12
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.Module)))
		i += copy(data[i:], *m.Module)
	}
	if m.Verdict == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x18
		i++
		i = encodeVarintCluegetter(data, i, uint64(*m.Verdict))
	}
	if m.Score == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x21
		i++
		i = encodeFixed64Cluegetter(data, i, uint64(math.Float64bits(*m.Score)))
	}
	if m.WeightedScore == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x29
		i++
		i = encodeFixed64Cluegetter(data, i, uint64(math.Float64bits(*m.WeightedScore)))
	}
	if m.Duration == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x31
		i++
		i = encodeFixed64Cluegetter(data, i, uint64(math.Float64bits(*m.Duration)))
	}
	if m.Determinants != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.Determinants)))
		i += copy(data[i:], m.Determinants)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeFixed64Cluegetter(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Cluegetter(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintCluegetter(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *Proto_MessageV1) Size() (n int) {
	var l int
	_ = l
	if m.Session != nil {
		l = m.Session.Size()
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.From != nil {
		l = len(*m.From)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if len(m.Rcpt) > 0 {
		for _, s := range m.Rcpt {
			l = len(s)
			n += 1 + l + sovCluegetter(uint64(l))
		}
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovCluegetter(uint64(l))
		}
	}
	if m.Body != nil {
		l = len(m.Body)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.Verdict != nil {
		n += 1 + sovCluegetter(uint64(*m.Verdict))
	}
	if m.VerdictMsg != nil {
		l = len(*m.VerdictMsg)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.RejectScore != nil {
		n += 9
	}
	if m.RejectScoreThreshold != nil {
		n += 9
	}
	if m.TempfailScore != nil {
		n += 9
	}
	if m.TempfailScoreThreshold != nil {
		n += 9
	}
	if len(m.CheckResults) > 0 {
		for _, e := range m.CheckResults {
			l = e.Size()
			n += 1 + l + sovCluegetter(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Proto_MessageV1_Session) Size() (n int) {
	var l int
	_ = l
	if m.InstanceId != nil {
		n += 1 + sovCluegetter(uint64(*m.InstanceId))
	}
	if m.Id != nil {
		l = len(m.Id)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.TimeStart != nil {
		n += 1 + sovCluegetter(uint64(*m.TimeStart))
	}
	if m.TimeEnd != nil {
		n += 1 + sovCluegetter(uint64(*m.TimeEnd))
	}
	if m.SaslUsername != nil {
		l = len(*m.SaslUsername)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.SaslSender != nil {
		l = len(*m.SaslSender)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.SaslMethod != nil {
		l = len(*m.SaslMethod)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.CertIssuer != nil {
		l = len(*m.CertIssuer)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.CertSubject != nil {
		l = len(*m.CertSubject)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.CipherBits != nil {
		n += 1 + sovCluegetter(uint64(*m.CipherBits))
	}
	if m.Cipher != nil {
		l = len(*m.Cipher)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.TlsVersion != nil {
		l = len(*m.TlsVersion)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.Ip != nil {
		l = len(*m.Ip)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.ReverseDns != nil {
		l = len(*m.ReverseDns)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.Hostname != nil {
		l = len(*m.Hostname)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.Helo != nil {
		l = len(*m.Helo)
		n += 2 + l + sovCluegetter(uint64(l))
	}
	if m.MtaHostName != nil {
		l = len(*m.MtaHostName)
		n += 2 + l + sovCluegetter(uint64(l))
	}
	if m.MtaDaemonName != nil {
		l = len(*m.MtaDaemonName)
		n += 2 + l + sovCluegetter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Proto_MessageV1_Header) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Proto_MessageV1_CheckResult) Size() (n int) {
	var l int
	_ = l
	if m.MessageId != nil {
		l = len(*m.MessageId)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.Module != nil {
		l = len(*m.Module)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.Verdict != nil {
		n += 1 + sovCluegetter(uint64(*m.Verdict))
	}
	if m.Score != nil {
		n += 9
	}
	if m.WeightedScore != nil {
		n += 9
	}
	if m.Duration != nil {
		n += 9
	}
	if m.Determinants != nil {
		l = len(m.Determinants)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCluegetter(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCluegetter(x uint64) (n int) {
	return sovCluegetter(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Proto_MessageV1) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluegetter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Proto_Message_v1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Proto_Message_v1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Proto_MessageV1_Session{}
			}
			if err := m.Session.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.From = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rcpt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rcpt = append(m.Rcpt, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &Proto_MessageV1_Header{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verdict", wireType)
			}
			var v Proto_MessageV1_Verdict
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (Proto_MessageV1_Verdict(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Verdict = &v
			hasFields[0] |= uint64(0x00000008)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerdictMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.VerdictMsg = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000010)
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RejectScore", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.RejectScore = &v2
			hasFields[0] |= uint64(0x00000020)
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RejectScoreThreshold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.RejectScoreThreshold = &v2
			hasFields[0] |= uint64(0x00000040)
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TempfailScore", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.TempfailScore = &v2
			hasFields[0] |= uint64(0x00000080)
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TempfailScoreThreshold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.TempfailScoreThreshold = &v2
			hasFields[0] |= uint64(0x00000100)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckResults = append(m.CheckResults, &Proto_MessageV1_CheckResult{})
			if err := m.CheckResults[len(m.CheckResults)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluegetter(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluegetter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000080) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000100) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proto_MessageV1_Session) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluegetter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Session: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Session: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InstanceId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeStart", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimeStart = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeEnd", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimeEnd = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaslUsername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.SaslUsername = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaslSender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.SaslSender = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaslMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.SaslMethod = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertIssuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.CertIssuer = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertSubject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.CertSubject = &s
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CipherBits", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CipherBits = &v
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cipher", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Cipher = &s
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.TlsVersion = &s
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Ip = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReverseDns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.ReverseDns = &s
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Hostname = &s
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Helo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Helo = &s
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MtaHostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.MtaHostName = &s
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MtaDaemonName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.MtaDaemonName = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluegetter(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluegetter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proto_MessageV1_Header) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluegetter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipCluegetter(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluegetter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proto_MessageV1_CheckResult) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluegetter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.MessageId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Module = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verdict", wireType)
			}
			var v Proto_MessageV1_Verdict
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (Proto_MessageV1_Verdict(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Verdict = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.Score = &v2
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightedScore", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.WeightedScore = &v2
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.Duration = &v2
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Determinants", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Determinants = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluegetter(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluegetter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCluegetter(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCluegetter
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCluegetter
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCluegetter
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCluegetter(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCluegetter = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCluegetter   = fmt.Errorf("proto: integer overflow")
)
