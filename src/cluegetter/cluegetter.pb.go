// Code generated by protoc-gen-gogo.
// source: cluegetter.proto
// DO NOT EDIT!

/*
	Package main is a generated protocol buffer package.

	It is generated from these files:
		cluegetter.proto

	It has these top-level messages:
		Proto_Message
		Proto_Session
		Rpc
		Rpc_Bayes_Learn_Message
		Rpc_Bayes_Learn_Message_Id
*/
package main

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import github_com_golang_protobuf_proto "github.com/golang/protobuf/proto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Proto_Message_Verdict int32

const (
	Proto_Message_PERMIT   Proto_Message_Verdict = 0
	Proto_Message_TEMPFAIL Proto_Message_Verdict = 1
	Proto_Message_REJECT   Proto_Message_Verdict = 2
	Proto_Message_ERROR    Proto_Message_Verdict = 3
)

var Proto_Message_Verdict_name = map[int32]string{
	0: "PERMIT",
	1: "TEMPFAIL",
	2: "REJECT",
	3: "ERROR",
}
var Proto_Message_Verdict_value = map[string]int32{
	"PERMIT":   0,
	"TEMPFAIL": 1,
	"REJECT":   2,
	"ERROR":    3,
}

func (x Proto_Message_Verdict) Enum() *Proto_Message_Verdict {
	p := new(Proto_Message_Verdict)
	*p = x
	return p
}
func (x Proto_Message_Verdict) String() string {
	return proto.EnumName(Proto_Message_Verdict_name, int32(x))
}
func (x *Proto_Message_Verdict) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Proto_Message_Verdict_value, data, "Proto_Message_Verdict")
	if err != nil {
		return err
	}
	*x = Proto_Message_Verdict(value)
	return nil
}

type Proto_Message struct {
	Session                *Proto_Session               `protobuf:"bytes,1,req,name=session" json:"session,omitempty"`
	Id                     *string                      `protobuf:"bytes,2,req,name=id" json:"id,omitempty"`
	From                   *string                      `protobuf:"bytes,3,req,name=from" json:"from,omitempty"`
	Rcpt                   []string                     `protobuf:"bytes,4,rep,name=rcpt" json:"rcpt,omitempty"`
	Headers                []*Proto_Message_Header      `protobuf:"bytes,5,rep,name=headers" json:"headers,omitempty"`
	Body                   []byte                       `protobuf:"bytes,6,opt,name=body" json:"body,omitempty"`
	Verdict                *Proto_Message_Verdict       `protobuf:"varint,7,req,name=verdict,enum=main.Proto_Message_Verdict" json:"verdict,omitempty"`
	VerdictMsg             *string                      `protobuf:"bytes,8,req,name=verdictMsg" json:"verdictMsg,omitempty"`
	RejectScore            *float64                     `protobuf:"fixed64,9,req,name=rejectScore" json:"rejectScore,omitempty"`
	RejectScoreThreshold   *float64                     `protobuf:"fixed64,10,req,name=rejectScoreThreshold" json:"rejectScoreThreshold,omitempty"`
	TempfailScore          *float64                     `protobuf:"fixed64,11,req,name=tempfailScore" json:"tempfailScore,omitempty"`
	TempfailScoreThreshold *float64                     `protobuf:"fixed64,12,req,name=tempfailScoreThreshold" json:"tempfailScoreThreshold,omitempty"`
	CheckResults           []*Proto_Message_CheckResult `protobuf:"bytes,13,rep,name=checkResults" json:"checkResults,omitempty"`
	XXX_unrecognized       []byte                       `json:"-"`
}

func (m *Proto_Message) Reset()         { *m = Proto_Message{} }
func (m *Proto_Message) String() string { return proto.CompactTextString(m) }
func (*Proto_Message) ProtoMessage()    {}

func (m *Proto_Message) GetSession() *Proto_Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *Proto_Message) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *Proto_Message) GetFrom() string {
	if m != nil && m.From != nil {
		return *m.From
	}
	return ""
}

func (m *Proto_Message) GetRcpt() []string {
	if m != nil {
		return m.Rcpt
	}
	return nil
}

func (m *Proto_Message) GetHeaders() []*Proto_Message_Header {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *Proto_Message) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Proto_Message) GetVerdict() Proto_Message_Verdict {
	if m != nil && m.Verdict != nil {
		return *m.Verdict
	}
	return Proto_Message_PERMIT
}

func (m *Proto_Message) GetVerdictMsg() string {
	if m != nil && m.VerdictMsg != nil {
		return *m.VerdictMsg
	}
	return ""
}

func (m *Proto_Message) GetRejectScore() float64 {
	if m != nil && m.RejectScore != nil {
		return *m.RejectScore
	}
	return 0
}

func (m *Proto_Message) GetRejectScoreThreshold() float64 {
	if m != nil && m.RejectScoreThreshold != nil {
		return *m.RejectScoreThreshold
	}
	return 0
}

func (m *Proto_Message) GetTempfailScore() float64 {
	if m != nil && m.TempfailScore != nil {
		return *m.TempfailScore
	}
	return 0
}

func (m *Proto_Message) GetTempfailScoreThreshold() float64 {
	if m != nil && m.TempfailScoreThreshold != nil {
		return *m.TempfailScoreThreshold
	}
	return 0
}

func (m *Proto_Message) GetCheckResults() []*Proto_Message_CheckResult {
	if m != nil {
		return m.CheckResults
	}
	return nil
}

type Proto_Message_CheckResult struct {
	MessageId        *string                `protobuf:"bytes,1,req,name=message_id" json:"message_id,omitempty"`
	Module           *string                `protobuf:"bytes,2,req,name=module" json:"module,omitempty"`
	Verdict          *Proto_Message_Verdict `protobuf:"varint,3,req,name=verdict,enum=main.Proto_Message_Verdict" json:"verdict,omitempty"`
	Score            *float64               `protobuf:"fixed64,4,req,name=score" json:"score,omitempty"`
	WeightedScore    *float64               `protobuf:"fixed64,5,req,name=weightedScore" json:"weightedScore,omitempty"`
	Duration         *float64               `protobuf:"fixed64,6,req,name=duration" json:"duration,omitempty"`
	Determinants     []byte                 `protobuf:"bytes,7,opt,name=determinants" json:"determinants,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *Proto_Message_CheckResult) Reset()         { *m = Proto_Message_CheckResult{} }
func (m *Proto_Message_CheckResult) String() string { return proto.CompactTextString(m) }
func (*Proto_Message_CheckResult) ProtoMessage()    {}

func (m *Proto_Message_CheckResult) GetMessageId() string {
	if m != nil && m.MessageId != nil {
		return *m.MessageId
	}
	return ""
}

func (m *Proto_Message_CheckResult) GetModule() string {
	if m != nil && m.Module != nil {
		return *m.Module
	}
	return ""
}

func (m *Proto_Message_CheckResult) GetVerdict() Proto_Message_Verdict {
	if m != nil && m.Verdict != nil {
		return *m.Verdict
	}
	return Proto_Message_PERMIT
}

func (m *Proto_Message_CheckResult) GetScore() float64 {
	if m != nil && m.Score != nil {
		return *m.Score
	}
	return 0
}

func (m *Proto_Message_CheckResult) GetWeightedScore() float64 {
	if m != nil && m.WeightedScore != nil {
		return *m.WeightedScore
	}
	return 0
}

func (m *Proto_Message_CheckResult) GetDuration() float64 {
	if m != nil && m.Duration != nil {
		return *m.Duration
	}
	return 0
}

func (m *Proto_Message_CheckResult) GetDeterminants() []byte {
	if m != nil {
		return m.Determinants
	}
	return nil
}

type Proto_Message_Header struct {
	Key              *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value            *string `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Proto_Message_Header) Reset()         { *m = Proto_Message_Header{} }
func (m *Proto_Message_Header) String() string { return proto.CompactTextString(m) }
func (*Proto_Message_Header) ProtoMessage()    {}

func (m *Proto_Message_Header) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *Proto_Message_Header) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type Proto_Session struct {
	InstanceId       *uint64 `protobuf:"varint,1,req,name=instanceId" json:"instanceId,omitempty"`
	Id               []byte  `protobuf:"bytes,2,req,name=id" json:"id,omitempty"`
	TimeStart        *uint64 `protobuf:"varint,3,req,name=timeStart" json:"timeStart,omitempty"`
	TimeEnd          *uint64 `protobuf:"varint,4,opt,name=timeEnd" json:"timeEnd,omitempty"`
	SaslUsername     *string `protobuf:"bytes,5,opt,name=saslUsername" json:"saslUsername,omitempty"`
	SaslSender       *string `protobuf:"bytes,6,opt,name=saslSender" json:"saslSender,omitempty"`
	SaslMethod       *string `protobuf:"bytes,7,opt,name=saslMethod" json:"saslMethod,omitempty"`
	CertIssuer       *string `protobuf:"bytes,8,opt,name=certIssuer" json:"certIssuer,omitempty"`
	CertSubject      *string `protobuf:"bytes,9,opt,name=certSubject" json:"certSubject,omitempty"`
	CipherBits       *uint32 `protobuf:"varint,10,opt,name=cipherBits" json:"cipherBits,omitempty"`
	Cipher           *string `protobuf:"bytes,11,opt,name=cipher" json:"cipher,omitempty"`
	TlsVersion       *string `protobuf:"bytes,12,opt,name=tlsVersion" json:"tlsVersion,omitempty"`
	Ip               *string `protobuf:"bytes,13,req,name=ip" json:"ip,omitempty"`
	ReverseDns       *string `protobuf:"bytes,14,opt,name=reverseDns" json:"reverseDns,omitempty"`
	Hostname         *string `protobuf:"bytes,15,opt,name=hostname" json:"hostname,omitempty"`
	Helo             *string `protobuf:"bytes,16,opt,name=helo" json:"helo,omitempty"`
	MtaHostName      *string `protobuf:"bytes,17,opt,name=mtaHostName" json:"mtaHostName,omitempty"`
	MtaDaemonName    *string `protobuf:"bytes,18,opt,name=mtaDaemonName" json:"mtaDaemonName,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Proto_Session) Reset()         { *m = Proto_Session{} }
func (m *Proto_Session) String() string { return proto.CompactTextString(m) }
func (*Proto_Session) ProtoMessage()    {}

func (m *Proto_Session) GetInstanceId() uint64 {
	if m != nil && m.InstanceId != nil {
		return *m.InstanceId
	}
	return 0
}

func (m *Proto_Session) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Proto_Session) GetTimeStart() uint64 {
	if m != nil && m.TimeStart != nil {
		return *m.TimeStart
	}
	return 0
}

func (m *Proto_Session) GetTimeEnd() uint64 {
	if m != nil && m.TimeEnd != nil {
		return *m.TimeEnd
	}
	return 0
}

func (m *Proto_Session) GetSaslUsername() string {
	if m != nil && m.SaslUsername != nil {
		return *m.SaslUsername
	}
	return ""
}

func (m *Proto_Session) GetSaslSender() string {
	if m != nil && m.SaslSender != nil {
		return *m.SaslSender
	}
	return ""
}

func (m *Proto_Session) GetSaslMethod() string {
	if m != nil && m.SaslMethod != nil {
		return *m.SaslMethod
	}
	return ""
}

func (m *Proto_Session) GetCertIssuer() string {
	if m != nil && m.CertIssuer != nil {
		return *m.CertIssuer
	}
	return ""
}

func (m *Proto_Session) GetCertSubject() string {
	if m != nil && m.CertSubject != nil {
		return *m.CertSubject
	}
	return ""
}

func (m *Proto_Session) GetCipherBits() uint32 {
	if m != nil && m.CipherBits != nil {
		return *m.CipherBits
	}
	return 0
}

func (m *Proto_Session) GetCipher() string {
	if m != nil && m.Cipher != nil {
		return *m.Cipher
	}
	return ""
}

func (m *Proto_Session) GetTlsVersion() string {
	if m != nil && m.TlsVersion != nil {
		return *m.TlsVersion
	}
	return ""
}

func (m *Proto_Session) GetIp() string {
	if m != nil && m.Ip != nil {
		return *m.Ip
	}
	return ""
}

func (m *Proto_Session) GetReverseDns() string {
	if m != nil && m.ReverseDns != nil {
		return *m.ReverseDns
	}
	return ""
}

func (m *Proto_Session) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func (m *Proto_Session) GetHelo() string {
	if m != nil && m.Helo != nil {
		return *m.Helo
	}
	return ""
}

func (m *Proto_Session) GetMtaHostName() string {
	if m != nil && m.MtaHostName != nil {
		return *m.MtaHostName
	}
	return ""
}

func (m *Proto_Session) GetMtaDaemonName() string {
	if m != nil && m.MtaDaemonName != nil {
		return *m.MtaDaemonName
	}
	return ""
}

type Rpc struct {
	Name             *string                   `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	XXX_extensions   map[int32]proto.Extension `json:"-"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *Rpc) Reset()         { *m = Rpc{} }
func (m *Rpc) String() string { return proto.CompactTextString(m) }
func (*Rpc) ProtoMessage()    {}

var extRange_Rpc = []proto.ExtensionRange{
	{256, 1023},
	{1024, 2047},
	{10000, 19000},
}

func (*Rpc) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_Rpc
}
func (m *Rpc) ExtensionMap() map[int32]proto.Extension {
	if m.XXX_extensions == nil {
		m.XXX_extensions = make(map[int32]proto.Extension)
	}
	return m.XXX_extensions
}

func (m *Rpc) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

type Rpc_Bayes_Learn_Message struct {
	IsSpam           *bool          `protobuf:"varint,1,req,name=is_spam" json:"is_spam,omitempty"`
	Message          *Proto_Message `protobuf:"bytes,2,req,name=message" json:"message,omitempty"`
	Host             *string        `protobuf:"bytes,17,opt,name=host" json:"host,omitempty"`
	Reporter         *string        `protobuf:"bytes,18,opt,name=reporter" json:"reporter,omitempty"`
	Reason           *string        `protobuf:"bytes,19,opt,name=reason" json:"reason,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *Rpc_Bayes_Learn_Message) Reset()         { *m = Rpc_Bayes_Learn_Message{} }
func (m *Rpc_Bayes_Learn_Message) String() string { return proto.CompactTextString(m) }
func (*Rpc_Bayes_Learn_Message) ProtoMessage()    {}

func (m *Rpc_Bayes_Learn_Message) GetIsSpam() bool {
	if m != nil && m.IsSpam != nil {
		return *m.IsSpam
	}
	return false
}

func (m *Rpc_Bayes_Learn_Message) GetMessage() *Proto_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *Rpc_Bayes_Learn_Message) GetHost() string {
	if m != nil && m.Host != nil {
		return *m.Host
	}
	return ""
}

func (m *Rpc_Bayes_Learn_Message) GetReporter() string {
	if m != nil && m.Reporter != nil {
		return *m.Reporter
	}
	return ""
}

func (m *Rpc_Bayes_Learn_Message) GetReason() string {
	if m != nil && m.Reason != nil {
		return *m.Reason
	}
	return ""
}

var E_Rpc_Bayes_Learn_Message_Bayes_Learn_Message = &proto.ExtensionDesc{
	ExtendedType:  (*Rpc)(nil),
	ExtensionType: (*Rpc_Bayes_Learn_Message)(nil),
	Field:         1024,
	Name:          "main.Rpc_Bayes_Learn_Message.Bayes_Learn_Message",
	Tag:           "bytes,1024,opt,name=Bayes_Learn_Message",
}

type Rpc_Bayes_Learn_Message_Id struct {
	IsSpam           *bool   `protobuf:"varint,1,req,name=is_spam" json:"is_spam,omitempty"`
	MessageId        *string `protobuf:"bytes,2,req,name=message_id" json:"message_id,omitempty"`
	Host             *string `protobuf:"bytes,17,opt,name=host" json:"host,omitempty"`
	Reporter         *string `protobuf:"bytes,18,opt,name=reporter" json:"reporter,omitempty"`
	Reason           *string `protobuf:"bytes,19,opt,name=reason" json:"reason,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Rpc_Bayes_Learn_Message_Id) Reset()         { *m = Rpc_Bayes_Learn_Message_Id{} }
func (m *Rpc_Bayes_Learn_Message_Id) String() string { return proto.CompactTextString(m) }
func (*Rpc_Bayes_Learn_Message_Id) ProtoMessage()    {}

func (m *Rpc_Bayes_Learn_Message_Id) GetIsSpam() bool {
	if m != nil && m.IsSpam != nil {
		return *m.IsSpam
	}
	return false
}

func (m *Rpc_Bayes_Learn_Message_Id) GetMessageId() string {
	if m != nil && m.MessageId != nil {
		return *m.MessageId
	}
	return ""
}

func (m *Rpc_Bayes_Learn_Message_Id) GetHost() string {
	if m != nil && m.Host != nil {
		return *m.Host
	}
	return ""
}

func (m *Rpc_Bayes_Learn_Message_Id) GetReporter() string {
	if m != nil && m.Reporter != nil {
		return *m.Reporter
	}
	return ""
}

func (m *Rpc_Bayes_Learn_Message_Id) GetReason() string {
	if m != nil && m.Reason != nil {
		return *m.Reason
	}
	return ""
}

var E_Rpc_Bayes_Learn_Message_Id_Bayes_Learn_Message_Id = &proto.ExtensionDesc{
	ExtendedType:  (*Rpc)(nil),
	ExtensionType: (*Rpc_Bayes_Learn_Message_Id)(nil),
	Field:         1025,
	Name:          "main.Rpc_Bayes_Learn_Message_Id.Bayes_Learn_Message_Id",
	Tag:           "bytes,1025,opt,name=Bayes_Learn_Message_Id",
}

func init() {
	proto.RegisterType((*Proto_Message)(nil), "main.Proto_Message")
	proto.RegisterType((*Proto_Message_CheckResult)(nil), "main.Proto_Message.CheckResult")
	proto.RegisterType((*Proto_Message_Header)(nil), "main.Proto_Message.Header")
	proto.RegisterType((*Proto_Session)(nil), "main.Proto_Session")
	proto.RegisterType((*Rpc)(nil), "main.Rpc")
	proto.RegisterType((*Rpc_Bayes_Learn_Message)(nil), "main.Rpc_Bayes_Learn_Message")
	proto.RegisterType((*Rpc_Bayes_Learn_Message_Id)(nil), "main.Rpc_Bayes_Learn_Message_Id")
	proto.RegisterEnum("main.Proto_Message_Verdict", Proto_Message_Verdict_name, Proto_Message_Verdict_value)
	proto.RegisterExtension(E_Rpc_Bayes_Learn_Message_Bayes_Learn_Message)
	proto.RegisterExtension(E_Rpc_Bayes_Learn_Message_Id_Bayes_Learn_Message_Id)
}
func (m *Proto_Message) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Proto_Message) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Session == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintCluegetter(data, i, uint64(m.Session.Size()))
		n1, err := m.Session.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Id == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x12
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.Id)))
		i += copy(data[i:], *m.Id)
	}
	if m.From == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x1a
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.From)))
		i += copy(data[i:], *m.From)
	}
	if len(m.Rcpt) > 0 {
		for _, s := range m.Rcpt {
			data[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Headers) > 0 {
		for _, msg := range m.Headers {
			data[i] = 0x2a
			i++
			i = encodeVarintCluegetter(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Body != nil {
		data[i] = 0x32
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.Body)))
		i += copy(data[i:], m.Body)
	}
	if m.Verdict == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x38
		i++
		i = encodeVarintCluegetter(data, i, uint64(*m.Verdict))
	}
	if m.VerdictMsg == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x42
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.VerdictMsg)))
		i += copy(data[i:], *m.VerdictMsg)
	}
	if m.RejectScore == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x49
		i++
		i = encodeFixed64Cluegetter(data, i, uint64(math.Float64bits(*m.RejectScore)))
	}
	if m.RejectScoreThreshold == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x51
		i++
		i = encodeFixed64Cluegetter(data, i, uint64(math.Float64bits(*m.RejectScoreThreshold)))
	}
	if m.TempfailScore == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x59
		i++
		i = encodeFixed64Cluegetter(data, i, uint64(math.Float64bits(*m.TempfailScore)))
	}
	if m.TempfailScoreThreshold == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x61
		i++
		i = encodeFixed64Cluegetter(data, i, uint64(math.Float64bits(*m.TempfailScoreThreshold)))
	}
	if len(m.CheckResults) > 0 {
		for _, msg := range m.CheckResults {
			data[i] = 0x6a
			i++
			i = encodeVarintCluegetter(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Proto_Message_CheckResult) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Proto_Message_CheckResult) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MessageId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.MessageId)))
		i += copy(data[i:], *m.MessageId)
	}
	if m.Module == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x12
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.Module)))
		i += copy(data[i:], *m.Module)
	}
	if m.Verdict == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x18
		i++
		i = encodeVarintCluegetter(data, i, uint64(*m.Verdict))
	}
	if m.Score == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x21
		i++
		i = encodeFixed64Cluegetter(data, i, uint64(math.Float64bits(*m.Score)))
	}
	if m.WeightedScore == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x29
		i++
		i = encodeFixed64Cluegetter(data, i, uint64(math.Float64bits(*m.WeightedScore)))
	}
	if m.Duration == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x31
		i++
		i = encodeFixed64Cluegetter(data, i, uint64(math.Float64bits(*m.Duration)))
	}
	if m.Determinants != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.Determinants)))
		i += copy(data[i:], m.Determinants)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Proto_Message_Header) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Proto_Message_Header) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.Key)))
		i += copy(data[i:], *m.Key)
	}
	if m.Value == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x12
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.Value)))
		i += copy(data[i:], *m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Proto_Session) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Proto_Session) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InstanceId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x8
		i++
		i = encodeVarintCluegetter(data, i, uint64(*m.InstanceId))
	}
	if m.Id == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x12
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(m.Id)))
		i += copy(data[i:], m.Id)
	}
	if m.TimeStart == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x18
		i++
		i = encodeVarintCluegetter(data, i, uint64(*m.TimeStart))
	}
	if m.TimeEnd != nil {
		data[i] = 0x20
		i++
		i = encodeVarintCluegetter(data, i, uint64(*m.TimeEnd))
	}
	if m.SaslUsername != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.SaslUsername)))
		i += copy(data[i:], *m.SaslUsername)
	}
	if m.SaslSender != nil {
		data[i] = 0x32
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.SaslSender)))
		i += copy(data[i:], *m.SaslSender)
	}
	if m.SaslMethod != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.SaslMethod)))
		i += copy(data[i:], *m.SaslMethod)
	}
	if m.CertIssuer != nil {
		data[i] = 0x42
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.CertIssuer)))
		i += copy(data[i:], *m.CertIssuer)
	}
	if m.CertSubject != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.CertSubject)))
		i += copy(data[i:], *m.CertSubject)
	}
	if m.CipherBits != nil {
		data[i] = 0x50
		i++
		i = encodeVarintCluegetter(data, i, uint64(*m.CipherBits))
	}
	if m.Cipher != nil {
		data[i] = 0x5a
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.Cipher)))
		i += copy(data[i:], *m.Cipher)
	}
	if m.TlsVersion != nil {
		data[i] = 0x62
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.TlsVersion)))
		i += copy(data[i:], *m.TlsVersion)
	}
	if m.Ip == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x6a
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.Ip)))
		i += copy(data[i:], *m.Ip)
	}
	if m.ReverseDns != nil {
		data[i] = 0x72
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.ReverseDns)))
		i += copy(data[i:], *m.ReverseDns)
	}
	if m.Hostname != nil {
		data[i] = 0x7a
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.Hostname)))
		i += copy(data[i:], *m.Hostname)
	}
	if m.Helo != nil {
		data[i] = 0x82
		i++
		data[i] = 0x1
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.Helo)))
		i += copy(data[i:], *m.Helo)
	}
	if m.MtaHostName != nil {
		data[i] = 0x8a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.MtaHostName)))
		i += copy(data[i:], *m.MtaHostName)
	}
	if m.MtaDaemonName != nil {
		data[i] = 0x92
		i++
		data[i] = 0x1
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.MtaDaemonName)))
		i += copy(data[i:], *m.MtaDaemonName)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Rpc) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Rpc) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.Name)))
		i += copy(data[i:], *m.Name)
	}
	if len(m.XXX_extensions) > 0 {
		n, err := github_com_golang_protobuf_proto.EncodeExtensionMap(m.XXX_extensions, data[i:])
		if err != nil {
			return 0, err
		}
		i += n
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Rpc_Bayes_Learn_Message) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Rpc_Bayes_Learn_Message) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsSpam == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x8
		i++
		if *m.IsSpam {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Message == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x12
		i++
		i = encodeVarintCluegetter(data, i, uint64(m.Message.Size()))
		n2, err := m.Message.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Host != nil {
		data[i] = 0x8a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.Host)))
		i += copy(data[i:], *m.Host)
	}
	if m.Reporter != nil {
		data[i] = 0x92
		i++
		data[i] = 0x1
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.Reporter)))
		i += copy(data[i:], *m.Reporter)
	}
	if m.Reason != nil {
		data[i] = 0x9a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.Reason)))
		i += copy(data[i:], *m.Reason)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Rpc_Bayes_Learn_Message_Id) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Rpc_Bayes_Learn_Message_Id) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsSpam == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x8
		i++
		if *m.IsSpam {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.MessageId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x12
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.MessageId)))
		i += copy(data[i:], *m.MessageId)
	}
	if m.Host != nil {
		data[i] = 0x8a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.Host)))
		i += copy(data[i:], *m.Host)
	}
	if m.Reporter != nil {
		data[i] = 0x92
		i++
		data[i] = 0x1
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.Reporter)))
		i += copy(data[i:], *m.Reporter)
	}
	if m.Reason != nil {
		data[i] = 0x9a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintCluegetter(data, i, uint64(len(*m.Reason)))
		i += copy(data[i:], *m.Reason)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeFixed64Cluegetter(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Cluegetter(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintCluegetter(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *Proto_Message) Size() (n int) {
	var l int
	_ = l
	if m.Session != nil {
		l = m.Session.Size()
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.From != nil {
		l = len(*m.From)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if len(m.Rcpt) > 0 {
		for _, s := range m.Rcpt {
			l = len(s)
			n += 1 + l + sovCluegetter(uint64(l))
		}
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovCluegetter(uint64(l))
		}
	}
	if m.Body != nil {
		l = len(m.Body)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.Verdict != nil {
		n += 1 + sovCluegetter(uint64(*m.Verdict))
	}
	if m.VerdictMsg != nil {
		l = len(*m.VerdictMsg)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.RejectScore != nil {
		n += 9
	}
	if m.RejectScoreThreshold != nil {
		n += 9
	}
	if m.TempfailScore != nil {
		n += 9
	}
	if m.TempfailScoreThreshold != nil {
		n += 9
	}
	if len(m.CheckResults) > 0 {
		for _, e := range m.CheckResults {
			l = e.Size()
			n += 1 + l + sovCluegetter(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Proto_Message_CheckResult) Size() (n int) {
	var l int
	_ = l
	if m.MessageId != nil {
		l = len(*m.MessageId)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.Module != nil {
		l = len(*m.Module)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.Verdict != nil {
		n += 1 + sovCluegetter(uint64(*m.Verdict))
	}
	if m.Score != nil {
		n += 9
	}
	if m.WeightedScore != nil {
		n += 9
	}
	if m.Duration != nil {
		n += 9
	}
	if m.Determinants != nil {
		l = len(m.Determinants)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Proto_Message_Header) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Proto_Session) Size() (n int) {
	var l int
	_ = l
	if m.InstanceId != nil {
		n += 1 + sovCluegetter(uint64(*m.InstanceId))
	}
	if m.Id != nil {
		l = len(m.Id)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.TimeStart != nil {
		n += 1 + sovCluegetter(uint64(*m.TimeStart))
	}
	if m.TimeEnd != nil {
		n += 1 + sovCluegetter(uint64(*m.TimeEnd))
	}
	if m.SaslUsername != nil {
		l = len(*m.SaslUsername)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.SaslSender != nil {
		l = len(*m.SaslSender)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.SaslMethod != nil {
		l = len(*m.SaslMethod)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.CertIssuer != nil {
		l = len(*m.CertIssuer)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.CertSubject != nil {
		l = len(*m.CertSubject)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.CipherBits != nil {
		n += 1 + sovCluegetter(uint64(*m.CipherBits))
	}
	if m.Cipher != nil {
		l = len(*m.Cipher)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.TlsVersion != nil {
		l = len(*m.TlsVersion)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.Ip != nil {
		l = len(*m.Ip)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.ReverseDns != nil {
		l = len(*m.ReverseDns)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.Hostname != nil {
		l = len(*m.Hostname)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.Helo != nil {
		l = len(*m.Helo)
		n += 2 + l + sovCluegetter(uint64(l))
	}
	if m.MtaHostName != nil {
		l = len(*m.MtaHostName)
		n += 2 + l + sovCluegetter(uint64(l))
	}
	if m.MtaDaemonName != nil {
		l = len(*m.MtaDaemonName)
		n += 2 + l + sovCluegetter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Rpc) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.XXX_extensions != nil {
		n += github_com_golang_protobuf_proto.SizeOfExtensionMap(m.XXX_extensions)
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Rpc_Bayes_Learn_Message) Size() (n int) {
	var l int
	_ = l
	if m.IsSpam != nil {
		n += 2
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.Host != nil {
		l = len(*m.Host)
		n += 2 + l + sovCluegetter(uint64(l))
	}
	if m.Reporter != nil {
		l = len(*m.Reporter)
		n += 2 + l + sovCluegetter(uint64(l))
	}
	if m.Reason != nil {
		l = len(*m.Reason)
		n += 2 + l + sovCluegetter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Rpc_Bayes_Learn_Message_Id) Size() (n int) {
	var l int
	_ = l
	if m.IsSpam != nil {
		n += 2
	}
	if m.MessageId != nil {
		l = len(*m.MessageId)
		n += 1 + l + sovCluegetter(uint64(l))
	}
	if m.Host != nil {
		l = len(*m.Host)
		n += 2 + l + sovCluegetter(uint64(l))
	}
	if m.Reporter != nil {
		l = len(*m.Reporter)
		n += 2 + l + sovCluegetter(uint64(l))
	}
	if m.Reason != nil {
		l = len(*m.Reason)
		n += 2 + l + sovCluegetter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCluegetter(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCluegetter(x uint64) (n int) {
	return sovCluegetter(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Proto_Message) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluegetter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Proto_Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Proto_Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Proto_Session{}
			}
			if err := m.Session.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.From = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rcpt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rcpt = append(m.Rcpt, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &Proto_Message_Header{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verdict", wireType)
			}
			var v Proto_Message_Verdict
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (Proto_Message_Verdict(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Verdict = &v
			hasFields[0] |= uint64(0x00000008)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerdictMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.VerdictMsg = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000010)
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RejectScore", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.RejectScore = &v2
			hasFields[0] |= uint64(0x00000020)
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RejectScoreThreshold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.RejectScoreThreshold = &v2
			hasFields[0] |= uint64(0x00000040)
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TempfailScore", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.TempfailScore = &v2
			hasFields[0] |= uint64(0x00000080)
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TempfailScoreThreshold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.TempfailScoreThreshold = &v2
			hasFields[0] |= uint64(0x00000100)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckResults = append(m.CheckResults, &Proto_Message_CheckResult{})
			if err := m.CheckResults[len(m.CheckResults)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluegetter(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluegetter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000080) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000100) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proto_Message_CheckResult) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluegetter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.MessageId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Module = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verdict", wireType)
			}
			var v Proto_Message_Verdict
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (Proto_Message_Verdict(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Verdict = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.Score = &v2
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeightedScore", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.WeightedScore = &v2
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.Duration = &v2
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Determinants", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Determinants = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluegetter(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluegetter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proto_Message_Header) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluegetter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipCluegetter(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluegetter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proto_Session) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluegetter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Proto_Session: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Proto_Session: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InstanceId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeStart", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimeStart = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeEnd", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimeEnd = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaslUsername", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.SaslUsername = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaslSender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.SaslSender = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaslMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.SaslMethod = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertIssuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.CertIssuer = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertSubject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.CertSubject = &s
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CipherBits", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CipherBits = &v
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cipher", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Cipher = &s
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.TlsVersion = &s
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Ip = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReverseDns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.ReverseDns = &s
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Hostname = &s
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Helo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Helo = &s
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MtaHostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.MtaHostName = &s
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MtaDaemonName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.MtaDaemonName = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluegetter(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluegetter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rpc) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluegetter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rpc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rpc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			if ((fieldNum >= 256) && (fieldNum < 1024)) || ((fieldNum >= 1024) && (fieldNum < 2048)) || ((fieldNum >= 10000) && (fieldNum < 19001)) {
				var sizeOfWire int
				for {
					sizeOfWire++
					wire >>= 7
					if wire == 0 {
						break
					}
				}
				iNdEx -= sizeOfWire
				skippy, err := skipCluegetter(data[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					return ErrInvalidLengthCluegetter
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				if m.XXX_extensions == nil {
					m.XXX_extensions = make(map[int32]github_com_golang_protobuf_proto.Extension)
				}
				m.XXX_extensions[int32(fieldNum)] = github_com_golang_protobuf_proto.NewExtension(data[iNdEx : iNdEx+skippy])
				iNdEx += skippy
			} else {
				iNdEx = preIndex
				skippy, err := skipCluegetter(data[iNdEx:])
				if err != nil {
					return err
				}
				if skippy < 0 {
					return ErrInvalidLengthCluegetter
				}
				if (iNdEx + skippy) > l {
					return io.ErrUnexpectedEOF
				}
				m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
				iNdEx += skippy
			}
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rpc_Bayes_Learn_Message) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluegetter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rpc_Bayes_Learn_Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rpc_Bayes_Learn_Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSpam", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsSpam = &b
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &Proto_Message{}
			}
			if err := m.Message.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Host = &s
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Reporter = &s
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Reason = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluegetter(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluegetter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rpc_Bayes_Learn_Message_Id) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCluegetter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rpc_Bayes_Learn_Message_Id: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rpc_Bayes_Learn_Message_Id: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSpam", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsSpam = &b
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.MessageId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Host = &s
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Reporter = &s
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCluegetter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Reason = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCluegetter(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCluegetter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCluegetter(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCluegetter
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCluegetter
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCluegetter
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCluegetter
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCluegetter(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCluegetter = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCluegetter   = fmt.Errorf("proto: integer overflow")
)
